# 关于C++

## 抄书

以下部分来自cppreference或者C++标准

C++ 程序是一个含有声明的文本文件序列。它们被翻译为一个可执行程序，程序在C++实现调用其主函数时被执行。
在C++程序中，一些被称为关键词的词语有着特殊的含义。其他词语可以被用作标识符。在翻译的过程中，注释会被忽略。C++程序也包含字面量，其中的字符的值由字符集与编码指定。程序中的某些特定字符必须通过转义字符表示。
C++程序中的实体包括值、对象、引用、结构化绑定（C++17起）、函数、枚举项、类型、类成员、模板、模板特化、包和命名空间。预处理宏不是C++实体。
声明可以引入实体，将它们与名字关联起来，并定义其属性。能够定义使用一个实体所需的所有属性的声明是定义。对任何被ODR使用的非内联函数或变量，程序中必须只有一个定义。
函数的定义通常包括一系列的语句，其中一部分会包含表达式。表达式指定了程序需要进行的运算。
程序中遇到的名字通过名字查找，与引入它们的声明关联起来。每个名字都只在称为其作用域的程序部分中有效。有些名字有链接，这使得它们即使出现在不同的作用域或翻译单元时，也代表相同的实体。
C++中的每一个对象、引用、函数和表达式都会关联一个类型，可以是基础类型，复合类型，或用户定义类型，以及完整或不完整类型等。
声明的不为非静态数据成员的对象和引用是变量。

C++程序可以创建、销毁、引用、访问并操作对象。
在C++中，一个对象拥有这些性质：
- 大小
- 对齐要求
- 存储期
- 生存期
- 类型
- 值
- 一个可选的名字

变量由声明引入，是对象或者是并非非静态数据成员的引用。

对象可以使用定义、new表达式、throw表达式、更改联合体的活跃成员和求值要求临时对象的表达式显式创建。显式对象创建完全定义了所创建的对象。

隐式生存期类型的对象也可以由以下操作隐式创建：
- 在常量求值以外的场合，开始类型unsigned char或std::byte的数组生存期的操作，此时在该数组中创建这种对象，
- 调用以下分配函数，此时在分配的存储中创建这种对象：
- 调用以下对象表示复制函数，此时在目标存储区域或结果中创建这种对象
- 调用下列特定的函数，此时在指定的存储区域中创建对象：

同一存储区域中可以创建零或多个对象，只要能给予程序有定义的行为即可。如果无法这样创建，例如操作冲突，那么程序行为未定义。如果多个这种隐式创建的对象的集合会给予程序有定义行为，那么不指定这些集合中的哪一个被创建。换言之，不要求隐式创建的对象是唯一定义的。

在指定的存储区域内隐式创建对象后，一些操作会生成指向已适当创建的对象的指针。已适当创建的对象与存储区域拥有相同地址。类似的，当且仅当不存在能给予程序有定义行为的指针时，行为才未定义；而如果有多个给予程序有定义行为的值，那么不指定产生哪个值。

调用std::allocator::allocate，或者联合体类型的隐式定义的复制/移动特殊成员函数，也能创建对象。

某些类型和对象具有对象表示和值表示，它们在下表中定义：

类型或对象的对象标识中不属于值表示的位是填充位。
对于可平凡复制类型，它的值表示是对象表示的一部分，这意味着复制该对象在存储中所占据的字节就足以产生另一个具有相同值的对象（除非该值是该类型的一个“陷阱表示”，将它读入到CPU中会产生一个硬件异常，就像浮点数的SNaN或整数的NaT
尽管大多数实现都不允许整数的陷阱表示、填充位或多重表示，但存在例外；例如Itanium上的整数类型值就可以是陷阱表示。
反过来不一定是对的：可平凡复制类型的两个具有不同对象补充的对象可能表现出相同的值。例如，浮点数有多种位模式都表示相同的特殊值NaN。更常见的是，会为了满足对齐要求和位域的大小等目的而引入填充位。
对于char，signed char和unsigned char类型的对象，除非它们是大小过大的位域，否则它的对象表示的每个位都参与它的值表示，而且每一种位模式都表示一个独立的值（没有填充位或陷阱位，不允许值的多种表示）

一个对象可以拥有子对象。子对象包括：
- 成员对象
- 基类对象
- 数组元素
不是其他任何对象的子对象的对象称为完整对象。
完整对象、成员对象和数组元素也被称为最终派生对象，以便和基类子对象区分开。
对于某个类，
- 它的非静态数据成员
- 它的非虚直接基类，以及
- 它不是抽象类时，它的虚基类。
被统称为该类的潜在构造的子对象。

如果一个子对象是基类子对象或者声明有`[[no_unique_address]]`属性的非静态数据成员，那么它是潜在重叠的子对象。
只有在满足以下所有条件时，对象obj的大小才有可能为零：
- obj是潜在重叠的子对象
- obj的类型是没有虚成员函数和虚基类的类类型
- obj没有非零大小的子对象，也没有非零长度的无名位域

对于满足以上所有条件的对象obj：
- 如果obj是没有非静态长远的标准布局类类型的基类子对象，那么它的大小为零

## 一些问题

- C++中的对象和面向对象编程中的对象含义的区别
- 不考虑兼容问题的情况下，对C++做哪种更改，会让C++更好
- C++标准引入对象表示和值表示的原因
- 对象与存储的关系，为什么一个非子对象必须占据存储。
- 移动语义窃取资源，似乎是对无法直接交换对象的存储的一种变通手段
